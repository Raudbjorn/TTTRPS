#!/usr/bin/env python3
"""
mbed - Enhanced embeddings management tool wrapper

This script ensures dependencies are installed and calls the main mbed_cli module.
"""

import sys
import os
import subprocess
import shutil
import signal
import atexit
from pathlib import Path
from typing import Optional, List

try:
    import requests
except ImportError:
    requests = None

def ensure_uv() -> bool:
    """Ensure uv package manager is installed"""
    if shutil.which('uv'):
        return True
    
    print("Installing uv package manager...")
    # SECURITY: Remove curl|sh vulnerability - use pip-only installation
    try:
        print("Installing uv via pip (secure method)...")
        subprocess.run([sys.executable, '-m', 'pip', 'install', 'uv'], 
                     check=True, capture_output=True)
        return True
    except subprocess.CalledProcessError as e:
        print(f"Warning: Could not install uv via pip: {e}")
        print("Using pip instead")
        return False

def ensure_venv() -> str:
    """Ensure we're in a virtual environment or use current Python"""
    # Check if we're already in a virtual environment
    if hasattr(sys, 'real_prefix') or (hasattr(sys, 'base_prefix') and sys.base_prefix != sys.prefix):
        # Already in a virtual environment
        return sys.executable
    
    # Check for existing .venv
    venv_path = Path('.venv')
    
    # Create venv if it doesn't exist
    if not venv_path.exists():
        print("Creating virtual environment...")
        try:
            if shutil.which('uv'):
                subprocess.run(['uv', 'venv'], check=True)
            else:
                subprocess.run([sys.executable, '-m', 'venv', '.venv'], check=True)
        except subprocess.CalledProcessError as e:
            print(f"Warning: Could not create virtual environment: {e}")
            return sys.executable
    
    # Get the python executable from venv
    if sys.platform == 'win32':
        python_exe = venv_path / 'Scripts' / 'python.exe'
    else:
        python_exe = venv_path / 'bin' / 'python'
    
    # Use current Python if venv doesn't have Python
    if not python_exe.exists():
        return sys.executable
    
    return str(python_exe)

def ensure_dependencies(python_exe: str, skip_check: bool = False) -> None:
    """Ensure all required dependencies are installed"""
    if skip_check:
        return
    
    print("Checking dependencies...")
    
    # Read requirements from requirements.txt
    script_dir = os.path.dirname(os.path.abspath(__file__))
    requirements_file = os.path.join(script_dir, 'requirements.txt')
    requirements = []
    
    if os.path.exists(requirements_file):
        try:
            with open(requirements_file, 'r') as f:
                for line in f:
                    line = line.strip()
                    # Skip comments, empty lines, and optional dependencies
                    if line and not line.startswith('#') and not line.startswith('//'):
                        # Extract package name before version specifier
                        pkg_name = line.split('>=')[0].split('==')[0].split('<=')[0].split(';')[0].strip()
                        if pkg_name:
                            requirements.append(pkg_name)
        except Exception as e:
            print(f"Warning: Could not read requirements.txt: {e}")
            # Fallback to core dependencies
            requirements = ['chromadb', 'psycopg2-binary', 'requests', 'numpy']
    else:
        # Fallback if no requirements.txt
        requirements = ['chromadb', 'psycopg2-binary', 'requests', 'numpy']
    
    # Optional but recommended
    optional = [
        'transformers',
        'optimum[openvino]',
        'nltk',
        'spacy',
        'sentence-transformers',
        'faiss-cpu'
    ]
    
    # Check and install missing packages with uv for speed
    has_uv = shutil.which('uv')
    missing_reqs = []
    
    # Map package names to import names  
    import_name_map = {
        'psycopg2-binary': 'psycopg2',
        'python-magic': 'magic',
        'tiktoken': 'tiktoken',
        'chardet': 'chardet',
        'filetype': 'filetype',
        'tqdm': 'tqdm',
        'aiofiles': 'aiofiles',
        'requests': 'requests',
        'numpy': 'numpy',
        'ollama': 'ollama',
        'chromadb': 'chromadb'
    }
    
    for req in requirements:
        package_name = req.split('[')[0].split('==')[0].split('>=')[0].split('<=')[0].split('~=')[0]
        import_name = import_name_map.get(package_name, package_name.replace('-', '_'))
        
        try:
            # Check if package is installed
            subprocess.run([python_exe, '-c', f'import {import_name}'],
                         capture_output=True, check=True)
        except subprocess.CalledProcessError:
            missing_reqs.append(req)
    
    # Install all missing requirements at once with uv
    if missing_reqs:
        print(f"Installing missing dependencies: {', '.join(missing_reqs)}")
        try:
            if has_uv:
                subprocess.run(['uv', 'pip', 'install'] + missing_reqs, check=True)
            else:
                subprocess.run([python_exe, '-m', 'pip', 'install'] + missing_reqs, check=True)
        except subprocess.CalledProcessError as e:
            print(f"Error installing required dependencies: {e}")
            raise
    
    # Try to install optional packages (don't fail if they don't work)
    for opt in optional:
        try:
            subprocess.run([python_exe, '-c', f'import {opt.split("[")[0].replace("-", "_")}'],
                         capture_output=True, check=True)
        except subprocess.CalledProcessError:
            try:
                print(f"Installing optional: {opt}...")
                if has_uv:
                    subprocess.run(['uv', 'pip', 'install', opt], 
                                 capture_output=True, check=True, timeout=30)
                else:
                    subprocess.run([python_exe, '-m', 'pip', 'install', opt],
                                 capture_output=True, check=True, timeout=30)
            except (subprocess.CalledProcessError, subprocess.TimeoutExpired) as e:
                print(f"Warning: Could not install optional package {opt}: {e}")
                # Optional packages can fail

# Global variable to track Ollama process
_ollama_process: Optional[subprocess.Popen] = None

def _cleanup_ollama() -> None:
    """Clean up Ollama process on exit"""
    global _ollama_process
    if _ollama_process and _ollama_process.poll() is None:
        try:
            _ollama_process.terminate()
            _ollama_process.wait(timeout=5)
        except (subprocess.TimeoutExpired, ProcessLookupError):
            try:
                _ollama_process.kill()
                _ollama_process.wait(timeout=2)
            except (subprocess.TimeoutExpired, ProcessLookupError):
                pass
        _ollama_process = None

def check_ollama() -> bool:
    """Check if Ollama is running and start if needed"""
    global _ollama_process
    
    try:
        if requests is None:
            raise ImportError("requests not available")
        response = requests.get("http://localhost:11434/api/version", timeout=2)
        if response.status_code == 200:
            return True
    except (requests.RequestException, ImportError) as e:
        print(f"Ollama not responding: {e}")
    
    # Try to start Ollama
    if shutil.which('ollama'):
        print("Starting Ollama service...")
        try:
            _ollama_process = subprocess.Popen(
                ['ollama', 'serve'], 
                stdout=subprocess.DEVNULL, 
                stderr=subprocess.DEVNULL,
                preexec_fn=os.setsid if hasattr(os, 'setsid') else None
            )
            # Register cleanup function
            atexit.register(_cleanup_ollama)
            
            import time
            time.sleep(3)
            
            # Verify it started
            try:
                import requests
                response = requests.get("http://localhost:11434/api/version", timeout=5)
                return response.status_code == 200
            except requests.RequestException:
                return False
                
        except (subprocess.SubprocessError, OSError) as e:
            print(f"Error starting Ollama: {e}")
            return False
    return False

def ensure_ollama_models() -> None:
    """Ensure required Ollama models are available"""
    if not shutil.which('ollama'):
        return
    
    models = ['nomic-embed-text', 'llama3.2:latest']
    
    try:
        result = subprocess.run(['ollama', 'list'], 
                              capture_output=True, text=True, check=True)
        
        for model in models:
            base_model = model.split(':')[0]
            if base_model not in result.stdout:
                print(f"Pulling Ollama model: {model}")
                print("This may take a few minutes on first run...")
                try:
                    subprocess.run(['ollama', 'pull', model], check=True, timeout=600)
                except (subprocess.CalledProcessError, subprocess.TimeoutExpired) as e:
                    print(f"Warning: Could not pull model {model}: {e}")
    except subprocess.CalledProcessError as e:
        print(f"Warning: Could not list Ollama models: {e}")

def main() -> None:
    """Main entry point"""
    # Use current Python executable by default - CRITICAL FIX: always initialize python_exe
    python_exe = sys.executable
    
    # Quick check for help or version flags
    if len(sys.argv) > 1 and sys.argv[1] in ['--help', '-h', '--version']:
        # Pass through to mbed_cli - python_exe is already set above
        pass
    else:
        # Check for --no-deps flag
        skip_deps = '--no-deps' in sys.argv
        
        if not skip_deps:
            try:
                # Ensure uv is installed for fast dependency management
                ensure_uv()
                
                # Ensure virtual environment (or use current)
                python_exe = ensure_venv()
                
                # Ensure dependencies using uv
                ensure_dependencies(python_exe, skip_deps)
                
                # Check Ollama if preprocessing is requested
                if '--preprocess' in sys.argv or '--gpu' in sys.argv:
                    if check_ollama():
                        ensure_ollama_models()
            except Exception as e:
                print(f"Warning: Error during setup: {e}")
                print("Continuing with current environment...")
    
    # IMPORT FIX: Add both parent and src directories to path for proper imports
    parent_dir = Path(__file__).parent
    src_dir = parent_dir / 'src'
    
    # Add parent directory first for relative imports
    if parent_dir.exists():
        sys.path.insert(0, str(parent_dir))
    
    # Add src directory for direct imports
    if src_dir.exists():
        sys.path.insert(0, str(src_dir))
    
    # Import and run the actual CLI with improved error handling
    try:
        # Try direct import first
        from embeddings.mbed_cli import main as mbed_main
        mbed_main()
    except ImportError:
        try:
            # Try with src prefix
            from src.embeddings.mbed_cli import main as mbed_main
            mbed_main()
        except ImportError as e:
            print(f"Error importing mbed_cli: {e}")
            print("Trying direct execution...")
            # Fallback: run as subprocess
            mbed_cli_path = parent_dir / 'src' / 'embeddings' / 'mbed_cli.py'
            if mbed_cli_path.exists():
                try:
                    subprocess.run([python_exe, str(mbed_cli_path)] + sys.argv[1:], check=True)
                except subprocess.CalledProcessError as e:
                    print(f"Error running mbed_cli: {e}")
                    sys.exit(1)
            else:
                print("Error: Could not find mbed_cli.py")
                sys.exit(1)
    except KeyboardInterrupt:
        print("\nOperation cancelled by user")
        sys.exit(130)
    except Exception as e:
        print(f"Unexpected error: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main()